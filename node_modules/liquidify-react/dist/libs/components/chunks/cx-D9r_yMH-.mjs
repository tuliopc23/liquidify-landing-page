function k(t) {
  return typeof t == "object" && t != null && !Array.isArray(t);
}
const z = (t) => typeof t == "object" && t !== null;
function R(t) {
  return Object.fromEntries(Object.entries(t ?? {}).filter(([r, n]) => n !== void 0));
}
const L = (t) => t === "base";
function F(t) {
  return t.slice().filter((r) => !L(r));
}
function x(t) {
  return String.fromCharCode(t + (t > 25 ? 39 : 97));
}
function X(t) {
  let r = "", n;
  for (n = Math.abs(t); n > 52; n = n / 52 | 0) r = x(n % 52) + r;
  return x(n % 52) + r;
}
function Y(t, r) {
  let n = r.length;
  for (; n; ) t = t * 33 ^ r.charCodeAt(--n);
  return t;
}
function D(t) {
  return X(Y(5381, t) >>> 0);
}
const E = /\s*!(important)?/i;
function N(t) {
  return typeof t == "string" ? E.test(t) : !1;
}
function H(t) {
  return typeof t == "string" ? t.replace(E, "").trim() : t;
}
function O(t) {
  return typeof t == "string" ? t.replaceAll(" ", "_") : t;
}
const _ = (t) => {
  const r = /* @__PURE__ */ new Map();
  return (...o) => {
    const e = JSON.stringify(o);
    if (r.has(e))
      return r.get(e);
    const i = t(...o);
    return r.set(e, i), i;
  };
}, G = /* @__PURE__ */ new Set(["__proto__", "constructor", "prototype"]);
function v(...t) {
  return t.reduce((r, n) => (n && Object.keys(n).forEach((o) => {
    if (G.has(o)) return;
    const e = r[o], i = n[o];
    k(e) && k(i) ? r[o] = v(e, i) : r[o] = i;
  }), r), {});
}
const q = (t) => t != null;
function j(t, r, n = {}) {
  const { stop: o, getKey: e } = n;
  function i(s, a = []) {
    if (z(s)) {
      const c = {};
      for (const [d, p] of Object.entries(s)) {
        const g = e?.(d, p) ?? d, l = [...a, g];
        if (o?.(s, l))
          return r(s, a);
        const b = i(p, l);
        q(b) && (c[g] = b);
      }
      return c;
    }
    return r(s, a);
  }
  return i(t);
}
function K(t, r) {
  return t.reduce((n, o, e) => {
    const i = r[e];
    return o != null && (n[i] = o), n;
  }, {});
}
function P(t, r, n = !0) {
  const { utility: o, conditions: e } = r, { hasShorthand: i, resolveShorthand: s } = o;
  return j(
    t,
    (a) => Array.isArray(a) ? K(a, e.breakpoints.keys) : a,
    {
      stop: (a) => Array.isArray(a),
      getKey: n ? (a) => i ? s(a) : a : void 0
    }
  );
}
const $ = {
  shift: (t) => t,
  finalize: (t) => t,
  breakpoints: { keys: [] }
}, Z = (t) => typeof t == "string" ? t.replaceAll(/[\n\s]+/g, " ") : t;
function U(t) {
  const { utility: r, hash: n, conditions: o = $ } = t, e = (s) => [r.prefix, s].filter(Boolean).join("-"), i = (s, a) => {
    let c;
    if (n) {
      const d = [...o.finalize(s), a];
      c = e(r.toHash(d, D));
    } else
      c = [...o.finalize(s), e(a)].join(":");
    return c;
  };
  return _(({ base: s, ...a } = {}) => {
    const c = Object.assign(a, s), d = P(c, t), p = /* @__PURE__ */ new Set();
    return j(d, (g, l) => {
      if (g == null) return;
      const b = N(g), [u, ...m] = o.shift(l), h = F(m), S = r.transform(u, H(Z(g)));
      let y = i(h, S.className);
      b && (y = `${y}!`), p.add(y);
    }), Array.from(p).join(" ");
  });
}
function J(...t) {
  return t.flat().filter((r) => k(r) && Object.keys(R(r)).length > 0);
}
function Q(t) {
  function r(e) {
    const i = J(...e);
    return i.length === 1 ? i : i.map((s) => P(s, t));
  }
  function n(...e) {
    return v(...r(e));
  }
  function o(...e) {
    return Object.assign({}, ...r(e));
  }
  return { mergeCss: _(n), assignCss: o };
}
const tt = /([A-Z])/g, rt = /^ms-/, nt = _((t) => t.startsWith("--") ? t : t.replace(tt, "-$1").replace(rt, "-ms-").toLowerCase()), ot = "cm,mm,Q,in,pc,pt,px,em,ex,ch,rem,lh,rlh,vw,vh,vmin,vmax,vb,vi,svw,svh,lvw,lvh,dvw,dvh,cqw,cqh,cqi,cqb,cqmin,cqmax,%";
`${ot.split(",").join("|")}`;
const _t = (t = {}) => {
  const r = (e) => ({
    className: [t.className, e].filter(Boolean).join("__"),
    base: t.base?.[e] ?? {},
    variants: {},
    defaultVariants: t.defaultVariants ?? {},
    compoundVariants: t.compoundVariants ? et(t.compoundVariants, e) : []
  }), o = (t.slots ?? []).map((e) => [e, r(e)]);
  for (const [e, i] of Object.entries(t.variants ?? {}))
    for (const [s, a] of Object.entries(i))
      o.forEach(([c, d]) => {
        d.variants[e] ??= {}, d.variants[e][s] = a[c] ?? {};
      });
  return Object.fromEntries(o);
}, et = (t, r) => t.filter((n) => n.css[r]).map((n) => ({ ...n, css: n.css[r] }));
function it(t, ...r) {
  const n = Object.getOwnPropertyDescriptors(t), o = Object.keys(n), e = (s) => {
    const a = {};
    for (let c = 0; c < s.length; c++) {
      const d = s[c];
      n[d] && (Object.defineProperty(a, d, n[d]), delete n[d]);
    }
    return a;
  }, i = (s) => e(Array.isArray(s) ? s : o.filter(s));
  return r.map(i).concat(e(o));
}
const st = (...t) => {
  const r = t.reduce((n, o) => (o && o.forEach((e) => n.add(e)), n), /* @__PURE__ */ new Set([]));
  return Array.from(r);
}, I = ["htmlSize", "htmlTranslate", "htmlWidth", "htmlHeight"];
function at(t) {
  return I.includes(t) ? t.replace("html", "").toLowerCase() : t;
}
function ct(t) {
  return Object.fromEntries(Object.entries(t).map(([r, n]) => [at(r), n]));
}
ct.keys = I;
const dt = "_hover,_focus,_focusWithin,_focusVisible,_disabled,_active,_visited,_target,_readOnly,_readWrite,_empty,_checked,_enabled,_expanded,_highlighted,_complete,_incomplete,_dragging,_before,_after,_firstLetter,_firstLine,_marker,_selection,_file,_backdrop,_first,_last,_only,_even,_odd,_firstOfType,_lastOfType,_onlyOfType,_peerFocus,_peerHover,_peerActive,_peerFocusWithin,_peerFocusVisible,_peerDisabled,_peerChecked,_peerInvalid,_peerExpanded,_peerPlaceholderShown,_groupFocus,_groupHover,_groupActive,_groupFocusWithin,_groupFocusVisible,_groupDisabled,_groupChecked,_groupExpanded,_groupInvalid,_indeterminate,_required,_valid,_invalid,_autofill,_inRange,_outOfRange,_placeholder,_placeholderShown,_pressed,_selected,_grabbed,_underValue,_overValue,_atValue,_default,_optional,_open,_closed,_fullscreen,_loading,_hidden,_current,_currentPage,_currentStep,_today,_unavailable,_rangeStart,_rangeEnd,_now,_topmost,_motionReduce,_motionSafe,_print,_landscape,_portrait,_dark,_light,_osDark,_osLight,_highContrast,_lessContrast,_moreContrast,_ltr,_rtl,_scrollbar,_scrollbarThumb,_scrollbarTrack,_horizontal,_vertical,_icon,_starting,_noscript,_invertedColors,base", T = new Set(dt.split(",")), lt = /^@|&|&$/;
function w(t) {
  return T.has(t) || lt.test(t);
}
const bt = /^_/, gt = /&|@/;
function pt(t) {
  return t.map((r) => T.has(r) ? r.replace(bt, "") : gt.test(r) ? `[${O(r.trim())}]` : r);
}
function ut(t) {
  return t.sort((r, n) => {
    const o = w(r), e = w(n);
    return o && !e ? 1 : !o && e ? -1 : 0;
  });
}
const mt = "aspectRatio:asp,boxDecorationBreak:bx-db,zIndex:z,boxSizing:bx-s,objectPosition:obj-p,objectFit:obj-f,overscrollBehavior:ovs-b,overscrollBehaviorX:ovs-bx,overscrollBehaviorY:ovs-by,position:pos/1,top:top,left:left,inset:inset,insetInline:inset-x/insetX,insetBlock:inset-y/insetY,insetBlockEnd:inset-be,insetBlockStart:inset-bs,insetInlineEnd:inset-e/insetEnd/end,insetInlineStart:inset-s/insetStart/start,right:right,bottom:bottom,float:float,visibility:vis,display:d,hideFrom:hide,hideBelow:show,flexBasis:flex-b,flex:flex,flexDirection:flex-d/flexDir,flexGrow:flex-g,flexShrink:flex-sh,gridTemplateColumns:grid-tc,gridTemplateRows:grid-tr,gridColumn:grid-c,gridRow:grid-r,gridColumnStart:grid-cs,gridColumnEnd:grid-ce,gridAutoFlow:grid-af,gridAutoColumns:grid-ac,gridAutoRows:grid-ar,gap:gap,gridGap:grid-g,gridRowGap:grid-rg,gridColumnGap:grid-cg,rowGap:rg,columnGap:cg,justifyContent:jc,alignContent:ac,alignItems:ai,alignSelf:as,padding:p/1,paddingLeft:pl/1,paddingRight:pr/1,paddingTop:pt/1,paddingBottom:pb/1,paddingBlock:py/1/paddingY,paddingBlockEnd:pbe,paddingBlockStart:pbs,paddingInline:px/paddingX/1,paddingInlineEnd:pe/1/paddingEnd,paddingInlineStart:ps/1/paddingStart,marginLeft:ml/1,marginRight:mr/1,marginTop:mt/1,marginBottom:mb/1,margin:m/1,marginBlock:my/1/marginY,marginBlockEnd:mbe,marginBlockStart:mbs,marginInline:mx/1/marginX,marginInlineEnd:me/1/marginEnd,marginInlineStart:ms/1/marginStart,spaceX:sx,spaceY:sy,outlineWidth:ring-w/ringWidth,outlineColor:ring-c/ringColor,outline:ring/1,outlineOffset:ring-o/ringOffset,focusRing:focus-ring,focusVisibleRing:focus-v-ring,focusRingColor:focus-ring-c,focusRingOffset:focus-ring-o,focusRingWidth:focus-ring-w,focusRingStyle:focus-ring-s,divideX:dvd-x,divideY:dvd-y,divideColor:dvd-c,divideStyle:dvd-s,width:w/1,inlineSize:w-is,minWidth:min-w/minW,minInlineSize:min-w-is,maxWidth:max-w/maxW,maxInlineSize:max-w-is,height:h/1,blockSize:h-bs,minHeight:min-h/minH,minBlockSize:min-h-bs,maxHeight:max-h/maxH,maxBlockSize:max-b,boxSize:size,color:c,fontFamily:ff,fontSize:fs,fontSizeAdjust:fs-a,fontPalette:fp,fontKerning:fk,fontFeatureSettings:ff-s,fontWeight:fw,fontSmoothing:fsmt,fontVariant:fv,fontVariantAlternates:fv-alt,fontVariantCaps:fv-caps,fontVariationSettings:fv-s,fontVariantNumeric:fv-num,letterSpacing:ls,lineHeight:lh,textAlign:ta,textDecoration:td,textDecorationColor:td-c,textEmphasisColor:te-c,textDecorationStyle:td-s,textDecorationThickness:td-t,textUnderlineOffset:tu-o,textTransform:tt,textIndent:ti,textShadow:tsh,textShadowColor:tsh-c/textShadowColor,textOverflow:tov,verticalAlign:va,wordBreak:wb,textWrap:tw,truncate:trunc,lineClamp:lc,listStyleType:li-t,listStylePosition:li-pos,listStyleImage:li-img,listStyle:li-s,backgroundPosition:bg-p/bgPosition,backgroundPositionX:bg-p-x/bgPositionX,backgroundPositionY:bg-p-y/bgPositionY,backgroundAttachment:bg-a/bgAttachment,backgroundClip:bg-cp/bgClip,background:bg/1,backgroundColor:bg-c/bgColor,backgroundOrigin:bg-o/bgOrigin,backgroundImage:bg-i/bgImage,backgroundRepeat:bg-r/bgRepeat,backgroundBlendMode:bg-bm/bgBlendMode,backgroundSize:bg-s/bgSize,backgroundGradient:bg-grad/bgGradient,backgroundLinear:bg-linear/bgLinear,backgroundRadial:bg-radial/bgRadial,backgroundConic:bg-conic/bgConic,textGradient:txt-grad,gradientFromPosition:grad-from-pos,gradientToPosition:grad-to-pos,gradientFrom:grad-from,gradientTo:grad-to,gradientVia:grad-via,gradientViaPosition:grad-via-pos,borderRadius:bdr/rounded,borderTopLeftRadius:bdr-tl/roundedTopLeft,borderTopRightRadius:bdr-tr/roundedTopRight,borderBottomRightRadius:bdr-br/roundedBottomRight,borderBottomLeftRadius:bdr-bl/roundedBottomLeft,borderTopRadius:bdr-t/roundedTop,borderRightRadius:bdr-r/roundedRight,borderBottomRadius:bdr-b/roundedBottom,borderLeftRadius:bdr-l/roundedLeft,borderStartStartRadius:bdr-ss/roundedStartStart,borderStartEndRadius:bdr-se/roundedStartEnd,borderStartRadius:bdr-s/roundedStart,borderEndStartRadius:bdr-es/roundedEndStart,borderEndEndRadius:bdr-ee/roundedEndEnd,borderEndRadius:bdr-e/roundedEnd,border:bd,borderWidth:bd-w,borderTopWidth:bd-t-w,borderLeftWidth:bd-l-w,borderRightWidth:bd-r-w,borderBottomWidth:bd-b-w,borderBlockStartWidth:bd-bs-w,borderBlockEndWidth:bd-be-w,borderColor:bd-c,borderInline:bd-x/borderX,borderInlineWidth:bd-x-w/borderXWidth,borderInlineColor:bd-x-c/borderXColor,borderBlock:bd-y/borderY,borderBlockWidth:bd-y-w/borderYWidth,borderBlockColor:bd-y-c/borderYColor,borderLeft:bd-l,borderLeftColor:bd-l-c,borderInlineStart:bd-s/borderStart,borderInlineStartWidth:bd-s-w/borderStartWidth,borderInlineStartColor:bd-s-c/borderStartColor,borderRight:bd-r,borderRightColor:bd-r-c,borderInlineEnd:bd-e/borderEnd,borderInlineEndWidth:bd-e-w/borderEndWidth,borderInlineEndColor:bd-e-c/borderEndColor,borderTop:bd-t,borderTopColor:bd-t-c,borderBottom:bd-b,borderBottomColor:bd-b-c,borderBlockEnd:bd-be,borderBlockEndColor:bd-be-c,borderBlockStart:bd-bs,borderBlockStartColor:bd-bs-c,opacity:op,boxShadow:bx-sh/shadow,boxShadowColor:bx-sh-c/shadowColor,mixBlendMode:mix-bm,filter:filter,brightness:brightness,contrast:contrast,grayscale:grayscale,hueRotate:hue-rotate,invert:invert,saturate:saturate,sepia:sepia,dropShadow:drop-shadow,blur:blur,backdropFilter:bkdp,backdropBlur:bkdp-blur,backdropBrightness:bkdp-brightness,backdropContrast:bkdp-contrast,backdropGrayscale:bkdp-grayscale,backdropHueRotate:bkdp-hue-rotate,backdropInvert:bkdp-invert,backdropOpacity:bkdp-opacity,backdropSaturate:bkdp-saturate,backdropSepia:bkdp-sepia,borderCollapse:bd-cl,borderSpacing:bd-sp,borderSpacingX:bd-sx,borderSpacingY:bd-sy,tableLayout:tbl,transitionTimingFunction:trs-tmf,transitionDelay:trs-dly,transitionDuration:trs-dur,transitionProperty:trs-prop,transition:trs,animation:anim,animationName:anim-n,animationTimingFunction:anim-tmf,animationDuration:anim-dur,animationDelay:anim-dly,animationPlayState:anim-ps,animationComposition:anim-comp,animationFillMode:anim-fm,animationDirection:anim-dir,animationIterationCount:anim-ic,animationRange:anim-r,animationState:anim-s,animationRangeStart:anim-rs,animationRangeEnd:anim-re,animationTimeline:anim-tl,transformOrigin:trf-o,transformBox:trf-b,transformStyle:trf-s,transform:trf,rotate:rotate,rotateX:rotate-x,rotateY:rotate-y,rotateZ:rotate-z,scale:scale,scaleX:scale-x,scaleY:scale-y,translate:translate,translateX:translate-x/x,translateY:translate-y/y,translateZ:translate-z/z,accentColor:ac-c,caretColor:ca-c,scrollBehavior:scr-bhv,scrollbar:scr-bar,scrollbarColor:scr-bar-c,scrollbarGutter:scr-bar-g,scrollbarWidth:scr-bar-w,scrollMargin:scr-m,scrollMarginLeft:scr-ml,scrollMarginRight:scr-mr,scrollMarginTop:scr-mt,scrollMarginBottom:scr-mb,scrollMarginBlock:scr-my/scrollMarginY,scrollMarginBlockEnd:scr-mbe,scrollMarginBlockStart:scr-mbt,scrollMarginInline:scr-mx/scrollMarginX,scrollMarginInlineEnd:scr-me,scrollMarginInlineStart:scr-ms,scrollPadding:scr-p,scrollPaddingBlock:scr-py/scrollPaddingY,scrollPaddingBlockStart:scr-pbs,scrollPaddingBlockEnd:scr-pbe,scrollPaddingInline:scr-px/scrollPaddingX,scrollPaddingInlineEnd:scr-pe,scrollPaddingInlineStart:scr-ps,scrollPaddingLeft:scr-pl,scrollPaddingRight:scr-pr,scrollPaddingTop:scr-pt,scrollPaddingBottom:scr-pb,scrollSnapAlign:scr-sa,scrollSnapStop:scrs-s,scrollSnapType:scrs-t,scrollSnapStrictness:scrs-strt,scrollSnapMargin:scrs-m,scrollSnapMarginTop:scrs-mt,scrollSnapMarginBottom:scrs-mb,scrollSnapMarginLeft:scrs-ml,scrollSnapMarginRight:scrs-mr,scrollSnapCoordinate:scrs-c,scrollSnapDestination:scrs-d,scrollSnapPointsX:scrs-px,scrollSnapPointsY:scrs-py,scrollSnapTypeX:scrs-tx,scrollSnapTypeY:scrs-ty,scrollTimeline:scrtl,scrollTimelineAxis:scrtl-a,scrollTimelineName:scrtl-n,touchAction:tch-a,userSelect:us,overflow:ov,overflowWrap:ov-wrap,overflowX:ov-x,overflowY:ov-y,overflowAnchor:ov-a,overflowBlock:ov-b,overflowInline:ov-i,overflowClipBox:ovcp-bx,overflowClipMargin:ovcp-m,overscrollBehaviorBlock:ovs-bb,overscrollBehaviorInline:ovs-bi,fill:fill,stroke:stk,strokeWidth:stk-w,strokeDasharray:stk-dsh,strokeDashoffset:stk-do,strokeLinecap:stk-lc,strokeLinejoin:stk-lj,strokeMiterlimit:stk-ml,strokeOpacity:stk-op,srOnly:sr,debug:debug,appearance:ap,backfaceVisibility:bfv,clipPath:cp-path,hyphens:hy,mask:msk,maskImage:msk-i,maskSize:msk-s,textSizeAdjust:txt-adj,container:cq,containerName:cq-n,containerType:cq-t,cursor:cursor", A = /* @__PURE__ */ new Map(), M = /* @__PURE__ */ new Map();
mt.split(",").forEach((t) => {
  const [r, n] = t.split(":"), [o, ...e] = n.split("/");
  A.set(r, o), e.length && e.forEach((i) => {
    M.set(i === "1" ? o : i, r);
  });
});
const C = (t) => M.get(t) || t, V = {
  conditions: {
    shift: ut,
    finalize: pt,
    breakpoints: { keys: ["base"] }
  },
  utility: {
    transform: (t, r) => {
      const n = C(t);
      return { className: `${A.get(n) || nt(n)}_${O(r)}` };
    },
    hasShorthand: !0,
    toHash: (t, r) => r(t.join(":")),
    resolveShorthand: C
  }
}, ft = U(V), W = (...t) => ft(f(...t));
W.raw = (...t) => f(...t);
const { mergeCss: f } = Q(V), B = (t) => ({
  base: {},
  variants: {},
  defaultVariants: {},
  compoundVariants: [],
  ...t
});
function ht(t) {
  const { base: r, variants: n, defaultVariants: o, compoundVariants: e } = B(t), i = (l) => ({ ...o, ...R(l) });
  function s(l = {}) {
    const b = i(l);
    let u = { ...r };
    for (const [h, S] of Object.entries(b))
      n[h]?.[S] && (u = f(u, n[h][S]));
    const m = St(e, b);
    return f(u, m);
  }
  function a(l) {
    const b = B(l.config), u = st(l.variantKeys, Object.keys(n));
    return ht({
      base: f(r, b.base),
      variants: Object.fromEntries(
        u.map((m) => [m, f(n[m], b.variants[m])])
      ),
      defaultVariants: v(o, b.defaultVariants),
      compoundVariants: [...e, ...b.compoundVariants]
    });
  }
  function c(l) {
    return W(s(l));
  }
  const d = Object.keys(n);
  function p(l) {
    return it(l, d);
  }
  const g = Object.fromEntries(
    Object.entries(n).map(([l, b]) => [l, Object.keys(b)])
  );
  return Object.assign(_(c), {
    __cva__: !0,
    variantMap: g,
    variantKeys: d,
    raw: s,
    config: t,
    merge: a,
    splitVariantProps: p,
    getVariantProps: i
  });
}
function St(t, r) {
  let n = {};
  return t.forEach((o) => {
    Object.entries(o).every(([i, s]) => i === "css" ? !0 : (Array.isArray(s) ? s : [s]).some((c) => r[i] === c)) && (n = f(n, o.css));
  }), n;
}
function yt(t, r, n, o) {
  if (r.length > 0 && typeof n?.[o] == "object")
    throw new Error(
      `[recipe:${t}:${o}] Conditions are not supported when using compound variants.`
    );
}
function kt() {
  let t = "", r = 0, n;
  for (; r < arguments.length; )
    (n = arguments[r++]) && typeof n == "string" && (t && (t += " "), t += n);
  return t;
}
export {
  W as a,
  R as b,
  kt as c,
  U as d,
  ut as e,
  pt as f,
  St as g,
  yt as h,
  _t as i,
  ht as j,
  _ as m,
  ct as n,
  it as s,
  st as u,
  O as w
};
//# sourceMappingURL=cx-D9r_yMH-.mjs.map
