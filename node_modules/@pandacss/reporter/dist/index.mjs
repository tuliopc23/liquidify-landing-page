// ../../node_modules/.pnpm/markdown-table@3.0.4/node_modules/markdown-table/index.js
function defaultStringLength(value) {
  return value.length;
}
function markdownTable(table2, options) {
  const settings = options || {};
  const align = (settings.align || []).concat();
  const stringLength = settings.stringLength || defaultStringLength;
  const alignments = [];
  const cellMatrix = [];
  const sizeMatrix = [];
  const longestCellByColumn = [];
  let mostCellsPerRow = 0;
  let rowIndex = -1;
  while (++rowIndex < table2.length) {
    const row2 = [];
    const sizes2 = [];
    let columnIndex2 = -1;
    if (table2[rowIndex].length > mostCellsPerRow) {
      mostCellsPerRow = table2[rowIndex].length;
    }
    while (++columnIndex2 < table2[rowIndex].length) {
      const cell = serialize(table2[rowIndex][columnIndex2]);
      if (settings.alignDelimiters !== false) {
        const size = stringLength(cell);
        sizes2[columnIndex2] = size;
        if (longestCellByColumn[columnIndex2] === void 0 || size > longestCellByColumn[columnIndex2]) {
          longestCellByColumn[columnIndex2] = size;
        }
      }
      row2.push(cell);
    }
    cellMatrix[rowIndex] = row2;
    sizeMatrix[rowIndex] = sizes2;
  }
  let columnIndex = -1;
  if (typeof align === "object" && "length" in align) {
    while (++columnIndex < mostCellsPerRow) {
      alignments[columnIndex] = toAlignment(align[columnIndex]);
    }
  } else {
    const code = toAlignment(align);
    while (++columnIndex < mostCellsPerRow) {
      alignments[columnIndex] = code;
    }
  }
  columnIndex = -1;
  const row = [];
  const sizes = [];
  while (++columnIndex < mostCellsPerRow) {
    const code = alignments[columnIndex];
    let before = "";
    let after = "";
    if (code === 99) {
      before = ":";
      after = ":";
    } else if (code === 108) {
      before = ":";
    } else if (code === 114) {
      after = ":";
    }
    let size = settings.alignDelimiters === false ? 1 : Math.max(
      1,
      longestCellByColumn[columnIndex] - before.length - after.length
    );
    const cell = before + "-".repeat(size) + after;
    if (settings.alignDelimiters !== false) {
      size = before.length + size + after.length;
      if (size > longestCellByColumn[columnIndex]) {
        longestCellByColumn[columnIndex] = size;
      }
      sizes[columnIndex] = size;
    }
    row[columnIndex] = cell;
  }
  cellMatrix.splice(1, 0, row);
  sizeMatrix.splice(1, 0, sizes);
  rowIndex = -1;
  const lines = [];
  while (++rowIndex < cellMatrix.length) {
    const row2 = cellMatrix[rowIndex];
    const sizes2 = sizeMatrix[rowIndex];
    columnIndex = -1;
    const line = [];
    while (++columnIndex < mostCellsPerRow) {
      const cell = row2[columnIndex] || "";
      let before = "";
      let after = "";
      if (settings.alignDelimiters !== false) {
        const size = longestCellByColumn[columnIndex] - (sizes2[columnIndex] || 0);
        const code = alignments[columnIndex];
        if (code === 114) {
          before = " ".repeat(size);
        } else if (code === 99) {
          if (size % 2) {
            before = " ".repeat(size / 2 + 0.5);
            after = " ".repeat(size / 2 - 0.5);
          } else {
            before = " ".repeat(size / 2);
            after = before;
          }
        } else {
          after = " ".repeat(size);
        }
      }
      if (settings.delimiterStart !== false && !columnIndex) {
        line.push("|");
      }
      if (settings.padding !== false && // Don’t add the opening space if we’re not aligning and the cell is
      // empty: there will be a closing space.
      !(settings.alignDelimiters === false && cell === "") && (settings.delimiterStart !== false || columnIndex)) {
        line.push(" ");
      }
      if (settings.alignDelimiters !== false) {
        line.push(before);
      }
      line.push(cell);
      if (settings.alignDelimiters !== false) {
        line.push(after);
      }
      if (settings.padding !== false) {
        line.push(" ");
      }
      if (settings.delimiterEnd !== false || columnIndex !== mostCellsPerRow - 1) {
        line.push("|");
      }
    }
    lines.push(
      settings.delimiterEnd === false ? line.join("").replace(/ +$/, "") : line.join("")
    );
  }
  return lines.join("\n");
}
function serialize(value) {
  return value === null || value === void 0 ? "" : String(value);
}
function toAlignment(value) {
  const code = typeof value === "string" ? value.codePointAt(0) : 0;
  return code === 67 || code === 99 ? 99 : code === 76 || code === 108 ? 108 : code === 82 || code === 114 ? 114 : 0;
}

// src/report-format.ts
import { table } from "table";
import Wordwrap from "wordwrapjs";
var plural = (count, singular) => {
  const pr = new Intl.PluralRules("en-US").select(count);
  const plural2 = pr === "one" || count === 0 ? singular : `${singular}s`;
  return `${count} ${plural2}`;
};
var createWrapFn = (enabled) => (str) => enabled ? Wordwrap.wrap(str, { width: 20 }) : str;
function formatTokenReport(result, format) {
  const headers = ["Token", "Usage %", "Most used", "Hardcoded", "Found in"];
  function getFormatted(entry, wrap) {
    const wrapFn = createWrapFn(wrap);
    return [
      `${entry.category} (${plural(entry.count, "token")})`,
      `${entry.percentUsed}% (${plural(entry.usedCount, "token")})`,
      wrapFn(entry.mostUsedNames.join(", ")),
      entry.hardcoded.toString(),
      `${plural(entry.usedInXFiles, "file")}`
    ];
  }
  switch (format) {
    case "json":
      return JSON.stringify(result, null, 2);
    case "markdown": {
      return markdownTable([headers, ...result.map((entry) => getFormatted(entry, true))]);
    }
    case "csv": {
      return [headers.join(","), ...result.map((entry) => getFormatted(entry, false).join(","))].join("\n");
    }
    case "table": {
      return table([headers, ...result.map((entry) => getFormatted(entry, true))]);
    }
    case "text":
    default: {
      const formatted = result.map((entry) => getFormatted(entry, false));
      return headers.map((header, index) => `${header}: ${formatted[index]}`).join("\n");
    }
  }
}
function formatRecipeReport(result, format) {
  function getFormatted(entry, wrap) {
    const wrapFn = createWrapFn(wrap);
    return [
      `${entry.recipeName} (${plural(entry.variantCount, "variant")})`,
      `${plural(entry.possibleCombinations.length, "value")}`,
      `${entry.percentUsed}% (${plural(entry.usedCombinations, "value")})`,
      wrapFn(entry.mostUsedCombinations.join(", ")),
      `${plural(entry.usedInXFiles, "file")}`,
      `jsx: ${entry.jsxPercentUsed}%
fn: ${entry.fnPercentUsed}%`
    ];
  }
  const headers = ["Recipe", "Variant values", "Usage %", "Most used", "Found in", "Used as"];
  switch (format) {
    case "json": {
      return JSON.stringify(result, null, 2);
    }
    case "markdown": {
      return table([headers, ...result.map((entry) => getFormatted(entry, true))]);
    }
    case "csv": {
      return [headers.join(","), ...result.map((entry) => getFormatted(entry, false).join(","))].join("\n");
    }
    case "table": {
      return table([headers, ...result.map((entry) => getFormatted(entry, true))]);
    }
    case "text":
    default: {
      const formatted = result.map((entry) => getFormatted(entry, false));
      return headers.map((header, index) => `${header}: ${formatted[index]}`).join("\n");
    }
  }
}

// src/reporter.ts
import { logger } from "@pandacss/logger";

// package.json
var version = "1.3.0";

// src/reporter-recipe.ts
function analyzeRecipes(ctx, result) {
  const recipesReportItems = Array.from(result.componentByIndex.values()).filter(
    (reportItem) => reportItem.reportItemType === "recipe" || reportItem.reportItemType === "jsx-recipe"
  );
  const recipeReportMap = /* @__PURE__ */ new Map();
  recipesReportItems.forEach((reportItem) => {
    const recipeOrComponentName = reportItem.componentName;
    const recipe = ctx.recipes.details.find(
      (node) => node.match.test(recipeOrComponentName) || node.baseName === recipeOrComponentName
    );
    if (!recipe) return;
    const recipeName = recipe?.baseName;
    if (!recipeReportMap.has(recipeName)) {
      recipeReportMap.set(recipeName, /* @__PURE__ */ new Set());
    }
    recipeReportMap.get(recipeName).add(reportItem);
  });
  const reportMap = Array.from(recipeReportMap.entries());
  const normalizedReportMap = reportMap.map(
    ([recipeName, reportItems]) => [recipeName, Array.from(reportItems)]
  );
  return normalizedReportMap.map(([recipeName, reportItems]) => {
    const usedCombinations = reportItems.map(
      (component) => component.contains.map((id) => {
        const reportItem = result.propByIndex.get(id);
        const recipe2 = ctx.recipes.getRecipe(recipeName);
        if (!recipe2?.variantKeys.includes(reportItem.propName)) return;
        return reportItem.propName + "." + reportItem.value;
      }).filter(Boolean)
    ).flat();
    const distinctUsedCombinations = Array.from(new Set(usedCombinations)).sort();
    const usedCount = reportItems.length;
    const recipe = ctx.recipes.getRecipe(recipeName);
    const variantMap = recipe.variantKeyMap ?? {};
    const possibleCombinations = Object.keys(variantMap).reduce((acc, variantName) => {
      return acc.concat(variantMap[variantName].map((value) => `${variantName}.${value}`));
    }, []);
    const variantCount = recipe.variantKeys.length;
    const percentUsed = Math.ceil(distinctUsedCombinations.length / (possibleCombinations.length || 1) * 1e4) / 100;
    const jsxUsage = reportItems.filter((component) => component.reportItemType === "jsx-recipe");
    const fnUsage = reportItems.filter((component) => component.reportItemType === "recipe");
    const jsxPercentUsed = Math.ceil(jsxUsage.length / (reportItems.length || 1) * 100);
    const fnPercentUsed = Math.ceil(fnUsage.length / (reportItems.length || 1) * 100);
    const usedInXFiles = new Set(reportItems.flatMap((component) => component.filepath)).size;
    return {
      recipeName,
      usedInXFiles,
      usedCount,
      variantCount,
      possibleCombinations,
      usedCombinations: distinctUsedCombinations.length,
      percentUsed,
      jsxPercentUsed,
      fnPercentUsed,
      unusedCombinations: possibleCombinations.length - distinctUsedCombinations.length,
      mostUsedCombinations: distinctUsedCombinations.slice(0, 5)
    };
  }).sort((a, b) => b.percentUsed - a.percentUsed);
}

// src/reporter-token.ts
import { uniq } from "@pandacss/shared";
var formatter = new Intl.NumberFormat("en-US", {
  maximumFractionDigits: 2,
  minimumFractionDigits: 2
});
var getPercent = (used, total) => {
  return Number(formatter.format(used / (total || 1) * 100));
};
function analyzeTokens(ctx, result) {
  const categoryMap = result.derived.globalMaps.byTokenType;
  const categoryEntries = Array.from(categoryMap.entries());
  const usageMap = /* @__PURE__ */ new Map();
  const totalMap = /* @__PURE__ */ new Map();
  categoryEntries.forEach(([category, categoryIds]) => {
    const usage = usageMap.get(category) || usageMap.set(category, []).get(category);
    categoryIds.forEach((id) => {
      const item = result.propByIndex.get(id);
      if (item?.value == null) return;
      const type = item.isKnownValue ? "token" : "nonToken";
      const value = item.value.toString();
      const filePath = item.filepath;
      const loc = item.range ? {
        line: item.range.startLineNumber,
        column: item.range.startColumn
      } : null;
      usage.push({ category, value, filePath, loc, type });
    });
    const totalTokens = ctx.tokens.view.categoryMap.get(category)?.size ?? 0;
    totalMap.set(category, totalTokens);
  });
  const usageEntries = Array.from(usageMap.entries());
  const percentMap = usageEntries.reduce((map, [category, usage]) => {
    const total = totalMap.get(category) ?? 0;
    const tokens = usage.reduce((acc, item) => {
      return item.type === "token" ? acc.add(item.value) : acc;
    }, /* @__PURE__ */ new Set());
    const percent = getPercent(tokens.size, total);
    return map.set(category, {
      total,
      used: tokens.size,
      unused: total - tokens.size,
      percent
    });
  }, /* @__PURE__ */ new Map());
  const tokenNameMap = usageEntries.reduce((map, [category, usage]) => {
    const existing = map.get(category) ?? [];
    usage.forEach(({ value, type }) => {
      if (type === "token") existing.push(value);
    });
    const sorted = uniq(existing).sort(
      (a, b) => (result.derived.globalMaps.byTokenName.get(b)?.size ?? 0) - (result.derived.globalMaps.byTokenName.get(a)?.size ?? 0)
    );
    return map.set(category, sorted);
  }, /* @__PURE__ */ new Map());
  const fileUsageMap = usageEntries.reduce((map, [category, usage]) => {
    const existing = map.get(category) ?? /* @__PURE__ */ new Set();
    usage.forEach(({ filePath }) => {
      if (filePath.startsWith("@config")) return;
      existing.add(filePath);
    });
    return map.set(category, existing);
  }, /* @__PURE__ */ new Map());
  const hardcodedTokenMap = usageEntries.reduce((map, [category, usage]) => {
    const items = /* @__PURE__ */ new Set();
    usage.forEach(({ type, value }) => {
      if (type === "nonToken") items.add(value);
    });
    return map.set(category, items.size);
  }, /* @__PURE__ */ new Map());
  return {
    usageMap,
    percentMap,
    tokenNameMap,
    fileUsageMap,
    hardcodedTokenMap,
    totalMap,
    getSummary() {
      const summary = categoryEntries.map(([category]) => {
        const percent = percentMap.get(category);
        return {
          category,
          count: percent?.total ?? 0,
          usedInXFiles: fileUsageMap.get(category)?.size ?? 0,
          usedCount: percent?.used ?? 0,
          percentUsed: percent?.percent ?? 0,
          hardcoded: hardcodedTokenMap.get(category) ?? 0,
          mostUsedNames: tokenNameMap.get(category)?.slice(0, 5) ?? []
        };
      });
      return summary.sort((a, b) => b.percentUsed - a.percentUsed);
    }
  };
}

// src/reporter.ts
var Reporter = class {
  constructor(ctx, options) {
    this.ctx = ctx;
    this.options = options;
  }
  #parserResults = /* @__PURE__ */ new Map();
  #extractTimes = /* @__PURE__ */ new Map();
  #sheet;
  #report;
  setup = () => {
    this.#sheet = this.ctx.createSheet();
    this.ctx.appendLayerParams(this.#sheet);
    this.ctx.appendBaselineCss(this.#sheet);
    this.parseFiles();
    this.ctx.appendParserCss(this.#sheet);
  };
  get report() {
    return this.#report;
  }
  parseFiles = () => {
    const { getFiles } = this.options;
    const files = getFiles();
    logger.info("analyze", `Analyzing ${files.length} file(s) for token and recipe usage...`);
    for (const file of files) {
      this.parseFile(file);
    }
  };
  parseFile = (file) => {
    const { project, getRelativePath, onResult } = this.options;
    const { config } = this.ctx;
    const start = performance.now();
    const result = project.parseSourceFile?.(file);
    const extractMs = performance.now() - start;
    const filePath = getRelativePath(config.cwd, file);
    this.#extractTimes.set(filePath, extractMs);
    logger.debug("analyze", `Parsed ${file} in ${extractMs}ms`);
    if (result) {
      this.#parserResults.set(filePath, result);
      onResult?.(file, result);
    }
  };
  init = () => {
    const { project } = this.options;
    this.setup();
    const classify = project.classify(this.#parserResults);
    this.#report = {
      schemaVersion: version,
      details: classify.details,
      propByIndex: classify.propById,
      componentByIndex: classify.componentById,
      derived: classify.derived
    };
  };
  getTokenReport = () => {
    const { project } = this.options;
    return analyzeTokens(project.parserOptions, this.#report);
  };
  getRecipeReport = () => {
    const { project } = this.options;
    return analyzeRecipes(project.parserOptions, this.#report);
  };
};
export {
  Reporter,
  formatRecipeReport,
  formatTokenReport
};
